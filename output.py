#!/usr/bin/env python3
# Data Mapping: csv_to_xml
# Auto-generated by DML Mapper

import csv
import json
import xml.etree.ElementTree as ET


# Transformation Functions
def transform_value(value, func_name: str, *args):
    """Apply transformation function to value."""
    if value is None:
        return None
    try:
        if func_name == "upper":
            return str(value).upper()
        elif func_name == "lower":
            return str(value).lower()
        elif func_name == "trim":
            return str(value).strip()
        elif func_name == "int":
            return int(value)
        elif func_name == "float":
            return float(value)
        elif func_name == "str":
            return str(value)
        elif func_name == "format_date":
            if args:
                return format_date_func(value, args[0])
        elif func_name == "format_number":
            if args:
                return format_number_func(value, args[0])
        elif func_name == "substring":
            if args:
                start = int(args[0]) if len(args) > 0 else 0
                end = int(args[1]) if len(args) > 1 else None
                return str(value)[start:end]
    except Exception:
        pass
    return value

# Date formatter
def format_date_func(value, fmt):
    """Format date value according to format string."""
    import datetime
    if isinstance(value, str):
        for fmt_str in ["%Y-%m-%d", "%d/%m/%Y", "%m/%d/%Y"]:
            try:
                dt = datetime.datetime.strptime(value, fmt_str)
                return dt.strftime(fmt.replace("YYYY", "%Y").replace("MM", "%m").replace("DD", "%d"))
            except ValueError:
                continue
    return value

# Number formatter
def format_number_func(value, fmt):
    """Format number according to format string."""
    try:
        num = float(value)
        if fmt == "#,##0.00":
            return f"{num:,.2f}"
        elif fmt == "999999.99":
            return f"{num:08.2f}"
    except (ValueError, TypeError):
        pass
    return value

# CSV Source Handler
def read_source(file_path: str, has_header: bool = True) -> List[Dict]:
    """Read data from CSV file."""
    items = []
    with open(file_path, "r", newline="") as f:
        if has_header:
            reader = csv.DictReader(f)
            for row in reader:
                items.append(dict(row))
        else:
            reader = csv.reader(f)
            headers = [f"col_{i}" for i in range(len(next(reader)))]
            f.seek(0)
            reader = csv.DictReader(f, fieldnames=headers)
            for row in reader:
                items.append(dict(row))
    return items

# XML Target Handler
def write_target(items: List[Dict], output_path: str, root_element: str = "Root"):
    """Write data to XML file."""
    root = ET.Element(root_element)
    for item in items:
        elem = ET.SubElement(root, "Item")
        for key, value in item.items():
            child = ET.SubElement(elem, key)
            child.text = str(value) if value else ""
    ET.ElementTree(root).write(output_path, encoding="utf-8", xml_declaration=True)

# Main Mapping Function
def execute_mapping(input_data: str, output_path: str) -> List[Dict]:
    """Execute the mapping and return transformed data."""
    source_items = read_source(input_data, has_header=true)

    # Transform items
    output_items = []
    for source_item in source_items:
        output_item = {}
        output_item["RecordID"] = source_item.get("id")
        output_item["RecordName"] = transform_value(source_item.get("name"), "upper", )
        output_item["RecordPrice"] = float(transform_value(source_item.get("price"), "float", ))
        output_items.append(output_item)

    write_target(output_items, output_path, root_element="Root")

    return output_items

if __name__ == "__main__":
    import sys
    if len(sys.argv) >= 3:
        result = execute_mapping(sys.argv[1], sys.argv[2])
        print(f"Mapping complete: {len(result)} items")
    else:
        print("Usage: python generated.py <input> <output>")
